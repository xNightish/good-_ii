import numpy as np
import matplotlib.pyplot as plt

# Логарифмическая функция потерь
def loss(w, x, y):
    M = np.dot(w, x) * y
    return np.log2(1 + np.exp(-M))

# Производная логарифмической функции потерь по вектору w
def df(w, x, y):
    M = np.dot(w, x) * y
    return -(np.exp(-M) * x * y) / ((1 + np.exp(-M)) * np.log(2))

data_x = [
    (5.3, 2.3), (5.7, 2.5), (4.0, 1.0), (5.6, 2.4), (4.5, 1.5),
    (5.4, 2.3), (4.8, 1.8), (4.5, 1.5), (5.1, 1.5), (6.1, 2.3),
    (5.1, 1.9), (4.0, 1.2), (5.2, 2.0), (3.9, 1.4), (4.2, 1.2),
    (4.7, 1.5), (4.8, 1.8), (3.6, 1.3), (4.6, 1.4), (4.5, 1.7),
    (3.0, 1.1), (4.3, 1.3), (4.5, 1.3), (5.5, 2.1), (3.5, 1.0),
    (5.6, 2.2), (4.2, 1.5), (5.8, 1.8), (5.5, 1.8), (5.7, 2.3),
    (6.4, 2.0), (5.0, 1.7), (6.7, 2.0), (4.0, 1.3), (4.4, 1.4),
    (4.5, 1.5), (5.6, 2.4), (5.8, 1.6), (4.6, 1.3), (4.1, 1.3),
    (5.1, 2.3), (5.2, 2.3), (5.6, 1.4), (5.1, 1.8), (4.9, 1.5),
    (6.7, 2.2), (4.4, 1.3), (3.9, 1.1), (6.3, 1.8), (6.0, 1.8),
    (4.5, 1.6), (6.6, 2.1), (4.1, 1.3), (4.5, 1.5), (6.1, 2.5),
    (4.1, 1.0), (4.4, 1.2), (5.4, 2.1), (5.0, 1.5), (5.0, 2.0),
    (4.9, 1.5), (5.9, 2.1), (4.3, 1.3), (4.0, 1.3), (4.9, 2.0),
    (4.9, 1.8), (4.0, 1.3), (5.5, 1.8), (3.7, 1.0), (6.9, 2.3),
    (5.7, 2.1), (5.3, 1.9), (4.4, 1.4), (5.6, 1.8), (3.3, 1.0),
    (4.8, 1.8), (6.0, 2.5), (5.9, 2.3), (4.9, 1.8), (3.3, 1.0),
    (3.9, 1.2), (5.6, 2.1), (5.8, 2.2), (3.8, 1.1), (3.5, 1.0),
    (4.5, 1.5), (5.1, 1.9), (4.7, 1.4), (5.1, 1.6), (5.1, 2.0),
    (4.8, 1.4), (5.0, 1.9), (5.1, 2.4), (4.6, 1.5), (6.1, 1.9),
    (4.7, 1.6), (4.7, 1.4), (4.7, 1.2), (4.2, 1.3), (4.2, 1.3)
]
data_y = [
    1, 1, -1, 1, -1, 1, 1, -1, 1, 1,
    1, -1, 1, -1, -1, -1, -1, -1, -1, 1,
    -1, -1, -1, 1, -1, 1, -1, 1, 1, 1,
    1, -1, 1, -1, -1, -1, 1, 1, -1, -1,
    1, 1, 1, 1, -1, 1, -1, -1, 1, 1,
    -1, 1, -1, -1, 1, -1, -1, 1, 1, 1,
    -1, 1, -1, -1, 1, 1, -1, 1, -1, 1,
    1, 1, -1, 1, -1, 1, 1, 1, 1, -1,
    -1, 1, 1, -1, -1, -1, 1, -1, -1, 1,
    -1, 1, 1, -1, 1, -1, -1, -1, -1, -1
]

# Подготовка данных для обучения
x_train = np.array([[1, x[0], x[1]] for x in data_x])
y_train = np.array(data_y)

n_train = len(x_train)  # Размер обучающей выборки
w = np.zeros(3)  # Начальные весовые коэффициенты
nt = np.array([0.1, 0.05, 0.05])  # Шаг обучения для каждого параметра w0, w1, w2
lm = 0.01  # Параметр лямбда для вычисления скользящего эмпирического среднего
N = 200  # Число итераций алгоритма SGD
batch_size = 10  # Размер мини-батча (величина K = 10)

alpha = 0.7  # Параметр для RMSProp
G = np.zeros(len(w))  # Параметр для RMSProp
eps = 1e-8  # Параметр для избежания деления на ноль

Qe = 0  # Начальное значение среднего эмпирического риска
np.random.seed(0)  # Генерация одинаковых последовательностей псевдослучайных чисел

for i in range(N):
    k = np.random.randint(0, n_train - batch_size)  # Случайный выбор индекса

    # Создание минибатча
    batch_x = x_train[k:k + batch_size]
    batch_y = y_train[k:k + batch_size]

    # Обновление Qe
    Qe = (1 - lm) * Qe + lm * np.mean([loss(w, x, y) for x, y in zip(batch_x, batch_y)])

    # Обновление весов
    gradient = np.mean([df(w, x, y) for x, y in zip(batch_x, batch_y)], axis=0)
    G = alpha * G + (1 - alpha) * gradient**2
    w -= nt * gradient / (np.sqrt(G) + eps)

# Оценка качества модели
Q = np.mean(x_train @ w.T * y_train < 0)

# Визуализация
plt.figure(figsize=(7, 4))  # Размер графика

# Отображение точек
plt.scatter(x_train[y_train == -1][:, 1], x_train[y_train == -1][:, 2], color='red', label='Класс -1')
plt.scatter(x_train[y_train == 1][:, 1], x_train[y_train == 1][:, 2], color='blue', label='Класс 1')


# Построение разделяющей линии
x_line = np.linspace(min(x_train[:, 1]), max(x_train[:, 1]), 100)
y_line = -(w[0] + w[1] * x_line) / w[2]
plt.plot(x_line, y_line, color='green', label='Разделяющая линия')

# Настройки графика
plt.ylabel('Признак 2')
plt.xlabel('Признак 1')

plt.legend()
plt.grid()

# Установка границ осей для уменьшения свободного пространства
plt.xlim(2.8, 7)  # Установите границы оси X
plt.ylim(0.8, 2.75)  # Установите границы оси Y
# сохранение графика
plt.savefig('task2_4_5.png')
# Показать график
plt.show()
