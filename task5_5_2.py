import numpy as np

# Данные
T = [
    [(365, 200), (390, 180), (350, 172), (400, 171)],
    [(77, 150), (100, 200), (50, 130)],
    [(250, 100), (170, 88), (280, 102), (230, 108)]
]

data_x = np.array([  # Преобразуем в массив NumPy
    (48, 118), (74, 96), (103, 82), (135, 76), (162, 79),
    (184, 97), (206, 111), (231, 118), (251, 118), (275, 110),
    (298, 86), (320, 68), (344, 62), (376, 61), (403, 75),
    (424, 95), (440, 114), (254, 80), (219, 85), (288, 66),
    (260, 92), (201, 76), (162, 66), (127, 135), (97, 143),
    (83, 160), (82, 177), (88, 199), (105, 205), (135, 208),
    (151, 198), (157, 169), (153, 152), (117, 158), (106, 168),
    (106, 185), (123, 188), (125, 171), (139, 163), (139, 183),
    (358, 127), (328, 132), (313, 146), (300, 169), (300, 181),
    (308, 197), (326, 206), (339, 209), (370, 199), (380, 184),
    (380, 147), (343, 154), (329, 169), (332, 184), (345, 185),
    (363, 159), (361, 177), (344, 169), (311, 175), (351, 89),
    (134, 96)
])

K = 3  # количество кластеров

# Инициализируем центры кластеров
centers = np.array([np.mean(cluster, axis=0) for cluster in T])

# Алгоритм Ллойда
for _ in range(10):
    # Присвоение точек к ближайшему центру кластера
    y = np.argmin(np.sum(np.abs(data_x[:, np.newaxis] - centers), axis=2), axis=1)
    # Обновление центров кластеров
    centers = np.array([data_x[y == m].mean(axis=0) if np.any(y == m) else centers[m] for m in range(K)])

# Результат кластеризации
X = [list(map(tuple, data_x[y == m])) for m in range(K)]

# Добавляем данные из T в X
for i, cluster in enumerate(T):
    X[i].extend(map(tuple, cluster))

# Вывод результата
for cluster in X:
    print(cluster)



